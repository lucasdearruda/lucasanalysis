// File: CountTreeEntries.cpp
// Usage examples (from a shell or ROOT):
//   root -l -q 'CountTreeEntries.cpp("path/to/dir","M","report.txt",true)'
//   root -l -q 'CountTreeEntries.cpp("file.root","M","report.txt")'
//   root -l -q 'CountTreeEntries.cpp("list.txt","M","report.txt")'
// Notes:
//  - treeName defaults to "M"
//  - If input is a directory, set recurse=true to walk subdirectories
//  - If input is a .txt file, it should contain absolute or relative paths to .root files (one per line)

#include <TFile.h>
#include <TTree.h>
#include <TSystem.h>
#include <TSystemFile.h>
#include <TSystemDirectory.h>

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <cctype>
#include <algorithm>


bool IsDirectory(const std::string& path) {
    // ROOT's AccessPathName returns false if file/dir exists
    if (gSystem->AccessPathName(path.c_str())) return false;
    TSystemFile file(path.c_str(), path.c_str());
    return file.IsDirectory();
}

namespace {
  static inline std::string Trim(std::string s) {
    auto notspace = [](int ch){ return !std::isspace(ch); };
    s.erase(s.begin(), std::find_if(s.begin(), s.end(), notspace));
    s.erase(std::find_if(s.rbegin(), s.rend(), notspace).base(), s.end());
    return s;
  }

  bool EndsWith(const std::string& s, const std::string& suf) {
    if (s.size() < suf.size()) return false;
    return std::equal(suf.rbegin(), suf.rend(), s.rbegin());
  }

  void ListRootFiles(const std::string& dir, bool recurse, std::vector<std::string>& out) {
    TSystemDirectory td(dir.c_str(), dir.c_str());
    TList* lst = td.GetListOfFiles();
    if (!lst) return;
    // ROOT can own list elements; prevent accidental deletion ordering issues
    TIter it(lst);
    while (TSystemFile* f = dynamic_cast<TSystemFile*>(it())) {
      std::string name = f->GetName();
      if (name == "." || name == "..") continue;
      std::string path = dir;
      if (!path.empty() && path.back() != '/') path += '/';
      path += name;

      if (f->IsDirectory()) {
        if (recurse) ListRootFiles(path, true, out);
      } else {
        if (EndsWith(name, ".root")) out.push_back(path);
      }
    }
  }

  void ReadListFile(const std::string& listPath, std::vector<std::string>& out) {
    std::ifstream in(listPath);
    std::string line;
    while (std::getline(in, line)) {
      line = Trim(line);
      if (line.empty() || line[0] == '#') continue;
      out.push_back(line);
    }
  }

  struct Stats {
    size_t files_total = 0;
    size_t files_ok = 0;
    size_t files_missing_tree = 0;
    size_t files_open_failed = 0;
    Long64_t entries_sum = 0;
  };

  void ProcessOne(const std::string& path,
                  const char* treeName,
                  std::ofstream& report,
                  Stats& stats) {
    ++stats.files_total;

    TFile* f = TFile::Open(path.c_str(), "READ");
    if (!f || f->IsZombie() || !f->IsOpen()) {
      report << path << "\tOPEN_FAILED\t-1\n";
      ++stats.files_open_failed;
      if (f) { f->Close(); delete f; }
      return;
    }

    TTree* t = nullptr;
    f->GetObject(treeName, t);
    if (!t) {
      report << path << "\tMISSING_TREE(" << treeName << ")\t-1\n";
      ++stats.files_missing_tree;
      f->Close(); delete f;
      return;
    }

    Long64_t n = t->GetEntries();
    report << path << "\tOK\t" << n << "\n";
    ++stats.files_ok;
    stats.entries_sum += n;

    f->Close();
    delete f;
  }
}

// Main entry point for ROOT
void CountTreeEntries(const char* inputPath = "reducedv7",
                      const char* treeName  = "M",
                      const char* reportTxt = "report.txt",
                      bool recurse          = false)
{
  std::vector<std::string> files;

  std::string in = inputPath ? std::string(inputPath) : std::string(".");
  bool isDir = IsDirectory(in);
  bool isRoot = EndsWith(in, ".root");
  bool isTxt = EndsWith(in, ".txt");

  if (isDir) {
    ListRootFiles(in, recurse, files);
  } else if (isRoot) {
    files.push_back(in);
  } else if (isTxt) {
    ReadListFile(in, files);
  } else {
    std::cerr << "[CountTreeEntries] Input is not a directory, .root, or .txt list: " << in << std::endl;
    return;
  }

  std::ofstream report(reportTxt);
  if (!report) {
    std::cerr << "[CountTreeEntries] Cannot open report file for writing: " << reportTxt << std::endl;
    return;
  }

  report << "# Report generated by CountTreeEntries\n";
  report << "# Input: " << in << "\n";
  report << "# Tree : " << treeName << "\n";
  report << "# Columns: <path>\t<status>\t<entries>\n";

  Stats stats;
  for (const auto& f : files) {
    ProcessOne(f, treeName, report, stats);
  }

  report << "# --- Summary ---\n";
  report << "# files_total       = " << stats.files_total << "\n";
  report << "# files_ok          = " << stats.files_ok << "\n";
  report << "# files_open_failed = " << stats.files_open_failed << "\n";
  report << "# files_no_tree     = " << stats.files_missing_tree << "\n";
  report << "# entries_sum       = " << stats.entries_sum << "\n";

  std::cout << "[CountTreeEntries] Done. Wrote: " << reportTxt << std::endl;
}
